local ScreenGui = Instance.new("ScreenGui")
local Button = Instance.new("ImageButton") -- Используем ImageButton

-- Настройка ScreenGui
ScreenGui.Parent = game.CoreGui

-- Настройка кнопки
Button.Parent = ScreenGui
Button.Size = UDim2.new(0, 50, 0, 50) -- Размер кнопки
Button.Position = UDim2.new(0, 10, 0, -10) -- Позиция кнопки
Button.BackgroundColor3 = Color3.new(1, 1, 1) -- Цвет фона кнопки

-- ID изображения
local imageId = "rbxassetid://127815828886309"
Button.Image = imageId

-- Настройка изображения
Button.ScaleType = Enum.ScaleType.Stretch -- Растягивание
Button.ImageTransparency = 0 -- Отключаем прозрачность

-- Предзагрузка изображения
local ContentProvider = game:GetService("ContentProvider")
ContentProvider:PreloadAsync({imageId})

-- Функция нажатия
Button.MouseButton1Click:Connect(function()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, nil) -- Нажатие
    task.wait(0.1) -- Задержка
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, nil) -- Отпускание
end)

local FluentUI = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveSys = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local UIManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local MainWindow = FluentUI:CreateWindow({
    Title = "Phantom System " .. FluentUI.Version,
    SubTitle = "Reimagined by cakein228",
    TabWidth = 150,
    Size = UDim2.fromOffset(600, 300),
    Acrylic = false, 
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl 
})

local Sections = {
    Dashboard = MainWindow:AddTab({ Title = "Dashboard" }),
    Config = MainWindow:AddTab({ Title = "Configuration" }),
    Updates = MainWindow:AddTab({ Title = "Upcoming Features" })
}

local AutoFarmToggle = Sections.Dashboard:AddToggle("AutoCollect", { Title = "Enable Auto Collect", Default = false })

AutoFarmToggle:OnChanged(function()
    _G.Collecting = AutoFarmToggle.Value
    print("Auto Collect status:", AutoFarmToggle.Value)
end)

_G.Collecting = false
_G.MoveSpeed = 30

local activeCoin, isMoving = nil, false
local coinStartTimestamp = nil

local PlayersService = game:GetService("Players")
local RunService = game:GetService("RunService")
local Player = PlayersService.LocalPlayer
local GameWorkspace = game:GetService("Workspace")

local function validateCharacter()
    return Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
end

local function checkCoinAppearance(coin)
    local visual = coin:FindFirstChild("CoinVisual")
    return visual and visual.Transparency == 0
end

local function locateClosestCoin()
    local closest, minDistance = nil, math.huge
    for _, coin in ipairs(GameWorkspace:GetDescendants()) do
        if coin.Name == "Coin_Server" and coin:IsA("Part") and checkCoinAppearance(coin) then 
            local distance = (coin.Position - Player.Character.HumanoidRootPart.Position).Magnitude
            if distance < minDistance then
                closest, minDistance = coin, distance
            end
        end
    end
    return closest
end

local function warpToCoin(coin)
    if not validateCharacter() then return end
    Player.Character.HumanoidRootPart.CFrame = coin.CFrame
end

local function navigateToCoin(coin)
    if not validateCharacter() then return end
    local root = Player.Character.HumanoidRootPart
    local gap = (coin.Position - root.Position).Magnitude

    if gap > 250 then
        warpToCoin(coin)
        isMoving = false
        return
    end

    if not checkCoinAppearance(coin) then
        isMoving = false
        return
    end

    if os.clock() - coinStartTimestamp > 10 then
        warpToCoin(coin)
        isMoving = false
        return
    end

    local direction = (coin.Position - root.Position).unit
    if gap > 0 then
        root.CFrame = CFrame.new(root.Position, coin.Position)
        root.CFrame = root.CFrame + direction * _G.MoveSpeed * RunService.Heartbeat:Wait()
    else
        isMoving = false
    end
end

RunService.Heartbeat:Connect(function()
    if not _G.Collecting or not validateCharacter() then return end

    if not isMoving then
        activeCoin = locateClosestCoin()
        if activeCoin then
            isMoving = true
            coinStartTimestamp = os.clock()
        end
    elseif activeCoin then
        navigateToCoin(activeCoin)
    end
end)

local AntiFlingToggle = Sections.Config:AddToggle("AntiFlingProtection", { Title = "Anti Fling Protection", Default = true })
local AntiFlingActive = false

AntiFlingToggle:OnChanged(function(state)
    AntiFlingActive = state
    print("Anti Fling state:", state)
end)

local function resetVelocity(part)
    if part:IsA("BasePart") then
        part.AssemblyAngularVelocity = Vector3.zero
        part.AssemblyLinearVelocity = Vector3.zero
        part.CanCollide = false
    end
end

local function monitorPlayer()
    local function onCharacterSpawn(character)
        local mainPart = character:WaitForChild("HumanoidRootPart", 5)
        local lastSafePosition = nil

        RunService.Heartbeat:Connect(function()
            if not AntiFlingActive or not mainPart then return end

            if mainPart.AssemblyLinearVelocity.Magnitude > 200 then
                resetVelocity(mainPart)
                if lastSafePosition then
                    mainPart.CFrame = lastSafePosition
                end
                game.StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "Unusual movement detected! Stabilizing...",
                    Color = Color3.fromRGB(255, 50, 50),
                })
            else
                lastSafePosition = mainPart.CFrame
            end
        end)
    end

    Player.CharacterAdded:Connect(onCharacterSpawn)
    if Player.Character then
        onCharacterSpawn(Player.Character)
    end
end

monitorPlayer()

Sections.Updates:AddParagraph({
    Title = "Coming Soon",
    Content = "Stay tuned for future updates and features!"
})

local NoclipToggle = Sections.Config:AddToggle("NoclipToggle", { Title = "Noclip", Default = false })

local noclipEnabled = true

local function toggleNoclip(state)
    noclipEnabled = state
    while noclipEnabled do
        local character = game.Players.LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
        task.wait()
    end
end

NoclipToggle:OnChanged(toggleNoclip)

local SpeedSlider = Sections.Config:AddSlider("MoveSpeed", {
    Title = "Movement Speed",
    Min = 16,
    Max = 100,
    Default = 20,
    Callback = function(value)
        _G.MoveSpeed = value
        print("Movement Speed set to:", value)
    end
})

local JumpSlider = Sections.Config:AddSlider("JumpHeight", {
    Title = "Jump Height",
    Min = 50,
    Max = 200,
    Default = 100,
    Callback = function(value)
        _G.JumpHeight = value
        print("Jump Height set to:", value)
    end
})

local NoclipToggle = Sections.Config:AddToggle("NoclipToggle", { Title = "Noclip", Default = false })
local noclipEnabled = false

local function toggleNoclip(state)
    noclipEnabled = state
    while noclipEnabled do
        local character = game.Players.LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
        task.wait()
    end
end

NoclipToggle:OnChanged(toggleNoclip)

local SpeedSlider = Sections.Config:AddSlider("MoveSpeed", {
    Title = "Movement Speed",
    Min = 16,
    Max = 100,
    Default = 20,
    Callback = function(value)
        _G.MoveSpeed = value
        print("Movement Speed set to:", value)
    end
})

local JumpSlider = Sections.Config:AddSlider("JumpHeight", {
    Title = "Jump Height",
    Min = 50,
    Max = 200,
    Default = 100,
    Callback = function(value)
        _G.JumpHeight = value
        print("Jump Height set to:", value)
    end
})

local NoclipToggle = Sections.Config:AddToggle("NoclipToggle", {
    Title = "Noclip", 
    Default = false,
    Callback = function(state)
        toggleNoclip(state)
    end
})

local noclipEnabled = false

local function toggleNoclip(state)
    noclipEnabled = state
    while noclipEnabled do
        local character = game.Players.LocalPlayer.Character
        if character then
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
        task.wait()
    end
end

local PlayersService = game:GetService("Players")
local RunService = game:GetService("RunService")
local Player = PlayersService.LocalPlayer
local GameWorkspace = game:GetService("Workspace")

local function validateCharacter()
    return Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
end

local function checkCoinAppearance(coin)
    local visual = coin:FindFirstChild("CoinVisual")
    return visual and visual.Transparency == 0
end

local function locateClosestCoin()
    local closest, minDistance = nil, math.huge
    for _, coin in ipairs(GameWorkspace:GetDescendants()) do
        if coin.Name == "Coin_Server" and coin:IsA("Part") and checkCoinAppearance(coin) then 
            local distance = (coin.Position - Player.Character.HumanoidRootPart.Position).Magnitude
            if distance < minDistance then
                closest, minDistance = coin, distance
            end
        end
    end
    return closest
end

local function warpToCoin(coin)
    if not validateCharacter() then return end
    Player.Character.HumanoidRootPart.CFrame = coin.CFrame
end

local function navigateToCoin(coin)
    if not validateCharacter() then return end
    local root = Player.Character.HumanoidRootPart
    local gap = (coin.Position - root.Position).Magnitude

    if gap > 250 then
        warpToCoin(coin)
        return
    end

    if not checkCoinAppearance(coin) then
        return
    end

    local direction = (coin.Position - root.Position).unit
    if gap > 0 then
        root.CFrame = CFrame.new(root.Position, coin.Position)
        root.CFrame = root.CFrame + direction * _G.MoveSpeed * RunService.Heartbeat:Wait()
    end
end

RunService.Heartbeat:Connect(function()
    if not validateCharacter() then return end

    local activeCoin = locateClosestCoin()
    if activeCoin then
        navigateToCoin(activeCoin)
    end
end)

-- Применяем изменения в скорости прыжка
local function applyJumpSpeed()
    local character = Player.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.JumpHeight = _G.JumpHeight
        end
    end
end

Player.CharacterAdded:Connect(function()
    applyJumpSpeed()
end)
-- Устанавливаем начальные значения
applyJumpSpeed()

-- Слайдер для скорости движения
local SpeedSlider = Tabs.Config:AddSlider("MoveSpeedSlider", {
    Title = "Movement Speed",  -- Название слайдера
    Description = "Change your movement speed",  -- Описание слайдера
    Default = 16,  -- Начальная скорость
    Min = 1,  -- Минимальное значение
    Max = 100,  -- Максимальное значение
    Rounding = 1,  -- Округление
    Callback = function(Value)
        print("Movement speed changed to:", Value)  -- Выводим в консоль
        game.Players.LocalPlayer.Character:WaitForChild("Humanoid").WalkSpeed = Value  -- Применяем значение скорости
    end
})

SpeedSlider:OnChanged(function(Value)
    print("Slider changed:", Value)  -- Логируем изменение слайдера
end)

SpeedSlider:SetValue(16)  -- Устанавливаем начальное значение

-- Слайдер для высоты прыжка
local JumpSlider = Tabs.Main:AddSlider("JumpHeightSlider", {
    Title = "Jump Height",  -- Название слайдера
    Description = "Change your jump height",  -- Описание слайдера
    Default = 50,  -- Начальная высота прыжка
    Min = 10,  -- Минимальное значение
    Max = 200,  -- Максимальное значение
    Rounding = 1,  -- Округление
    Callback = function(Value)
        print("Jump height changed to:", Value)  -- Выводим в консоль
        game.Players.LocalPlayer.Character:WaitForChild("Humanoid").JumpHeight = Value  -- Применяем значение высоты прыжка
    end
})

JumpSlider:OnChanged(function(Value)
    print("Slider changed:", Value)  -- Логируем изменение слайдера
end)

JumpSlider:SetValue(50)  -- Устанавливаем начальное значение
